global name 'time' is not definedglobal name 'sys' is not definedglobal name 'adjacent' is not definedlocal variable 'endpoint_count' referenced before assignmentglobal name 'itertools' is not definedlocal variable 'chord1' referenced before assignmentlocal variable 'chord2' referenced before assignmentlocal variable 'a' referenced before assignmentlocal variable 'c' referenced before assignmentlocal variable 'n' referenced before assignmentlocal variable 'b' referenced before assignmentlocal variable 'adj' referenced before assignmentlocal variable 'chord_count' referenced before assignmentlocal variable 'ep_list' referenced before assignmentglobal name 'error' is not definedlocal variable 'endpoint_list' referenced before assignmentlocal variable 'chord_list' referenced before assignmentlocal variable 'i' referenced before assignmentlocal variable 'chords' referenced before assignmentglobal name 'timestamp' is not definedglobal name 'get_possible_chords' is not definedglobal name '_add_chords_to_diag' is not definedlocal variable 'count' referenced before assignmentlocal variable 'diagram' referenced before assignmentlocal variable 'ep1' referenced before assignmentlocal variable 'current_used_eps' referenced before assignmentlocal variable 'ep2' referenced before assignmentlocal variable 'current_diagram' referenced before assignmentlocal variable 'chord' referenced before assignmentlocal variable 'possible_chords' referenced before assignmentlocal variable 'partial_diagram' referenced before assignmentlocal variable 'used_eps' referenced before assignmentlocal variable 'dofilter' referenced before assignmentlocal variable 'indent' referenced before assignmentlocal variable 'diag' referenced before assignmentglobal name 'get_sorted_diagram' is not definedlocal variable 'endpoints_set' referenced before assignmentlocal variable 'ep_map' referenced before assignmentlocal variable 'sparse_diagram' referenced before assignmentlocal variable 'diag1' referenced before assignmentlocal variable 'diag2' referenced before assignmentglobal name 'equal_diagrams' is not definedglobal name 'get_rotated_diagram' is not definedglobal name 'get_scaled_diagram' is not definedglobal name 'get_compressed_diagram' is not definedglobal name 'contains_one_move' is not definedglobal name 'contains_two_move' is not definedglobal name 'contains_three_move' is not definedlocal variable 'scaled_diag' referenced before assignmentlocal variable 'invariant_chords' referenced before assignmentlocal variable 'ext_chord' referenced before assignmentglobal name 'get_symetric_diagram' is not definedglobal name 'equal_rotated_diagrams' is not definedlocal variable 'inner_diag' referenced before assignmentlocal variable 'i_ep_info' referenced before assignmentlocal variable 'odiag' referenced before assignmentlocal variable 'o_ep_info' referenced before assignmentglobal name '_do_fits_into' is not definedlocal variable 'skipable' referenced before assignmentlocal variable 'inner_next' referenced before assignmentlocal variable 'outer_next' referenced before assignmentlocal variable 'i_matched' referenced before assignmentlocal variable 'o_matched' referenced before assignmentlocal variable 'idiag' referenced before assignmentglobal name 'get_possible_diagrams' is not definedglobal name 'is_realizable_diagram' is not definedglobal name 'display_moves' is not definedglobal name 'get_invariant_chords_for_diagram' is not definedglobal name 'Span' is not definedlocal variable 'self' referenced before assignmentlocal variable 'span' referenced before assignmentglobal name 'Boundaries' is not definedglobal name 'Diagram' is not definedglobal name 'Region' is not definedglobal name 'ordered' is not definedlocal variable 'region1' referenced before assignmentlocal variable 'region2' referenced before assignmentlocal variable 'spans' referenced before assignmentlocal variable 'new_span' referenced before assignmentlocal variable 'new_spans' referenced before assignmentlocal variable 'updated_boundaries' referenced before assignmentlocal variable 'boundary_name' referenced before assignmentlocal variable 'last_span' referenced before assignmentlocal variable 'name' referenced before assignmentlocal variable 'region_tuples' referenced before assignmentlocal variable 'node' referenced before assignmentlocal variable 'node1' referenced before assignmentlocal variable 'node2' referenced before assignmentlocal variable 'regions' referenced before assignmentlocal variable 'region' referenced before assignmentlocal variable 'result' referenced before assignmentlocal variable 'span_loop' referenced before assignmentlocal variable 'unused_spans' referenced before assignmentlocal variable 'node_complement' referenced before assignmentlocal variable 'terminal_node' referenced before assignmentlocal variable 'spans_by_region' referenced before assignmentlocal variable 'region_spans' referenced before assignmentglobal name 'Chord' is not definedlocal variable 'initial_span' referenced before assignmentlocal variable 'chord_forms_loop' referenced before assignmentlocal variable 'start_node' referenced before assignmentlocal variable 'final_node' referenced before assignmentlocal variable 'boundaries' referenced before assignmentlocal variable 'bounding_spans' referenced before assignmentglobal name 'deepcopy' is not definedlocal variable 'new_boundaries' referenced before assignmentlocal variable 'boundary_info' referenced before assignmentlocal variable 'region_count_before' referenced before assignmentlocal variable 'intersections' referenced before assignmentlocal variable 'max_node' referenced before assignmentlocal variable 'region_boundaries' referenced before assignmentlocal variable 'base_region' referenced before assignmentlocal variable 'inside_region' referenced before assignmentlocal variable 'high_end_span' referenced before assignmentlocal variable 'diag_max_node' referenced before assignmentlocal variable 'bound_str' referenced before assignmentlocal variable 'nodes_set' referenced before assignmentlocal variable 'node_map' referenced before assignmentlocal variable 'chords_to_remove' referenced before assignmentlocal variable 'loop_count' referenced before assignmentlocal variable 'new_region' referenced before assignmentname 'main' is not definedglobal name 'Value' is not definedglobal name 'count' is not definedglobal name 'save_data' is not definedglobal name 'results' is not definedglobal name 'data_filename' is not definedlocal variable 'rot_diag' referenced before assignmentglobal name 'Manager' is not definedglobal name 'manager' is not definedglobal name 'os' is not definedglobal name 'load_data' is not definedglobal name 'Pool' is not definedglobal name 'init' is not definedlocal variable 'results' referenced before assignmentlocal variable 'data_filename' referenced before assignmentglobal name 'check_diagram' is not definedlocal variable 'rvs' referenced before assignmentglobal name 'json' is not definedlocal variable 'value' referenced before assignmentlocal variable 'key' referenced before assignmentlocal variable 'records_loaded' referenced before assignmentglobal name 'getopt' is not definedglobal name 'usage' is not definedlocal variable 'progname' referenced before assignmentlocal variable 'opts' referenced before assignmentlocal variable 'opt' referenced before assignmentlocal variable 'arg' referenced before assignmentlocal variable 'n_chords' referenced before assignmentglobal name 'check_all_n_chord_diagrams' is not definedmsgdeltadiagspairswritefactordoPrintdoScaletriplesrotationsfilterEvenouter_diaginner_chordchord_lengthcombinationsmirror_diag1extended_diagget_chord_keyfits_into_diagrampossible_chord_rowpossible_ext_chordsequal_symetric_diagramscheck_diagram_invariance{} possible diagram count: {}one:%s	two:%s	three:%s
Realizable diagrams for size=%sMatch remaining portion if idiag into odiag{} Start generating diagrams-- no qualifying diagrams --{} Done generating diagramsReturns True if diag1 == diag2.  i.e. same chords, any order For ep_list=(1, 2, 3, 4), return list of lists like:
        [ [(1,2), (1,3), (1,4)],
                 [(2,3), (2,4)],
                        [(3,4)] ]
    ext chord:/Users/melewitz/Documents/LiClipse Workspace/ICDIndicator/ICDIndicator.pyscaled diag:Returns the distance between the chord endpoints
       Size is the number of endpoints in the diagram
       Chord length is never over 1/2 the number endpoints as it's
         then shorter to go the other way around the diagram.
    Return true if diagram contains a one-move.
       i.e. if the endpoints of any chord are adjacentInvariant chords:Return true if diagram contains a one-move.
       i.e. if any two chords have adjacent endpointsAdd chord to diagram and return True if no 1, 2, or 3 moves are found
       Assumes input diagram is already scaled, doesn't check for endpoint conflictsReturns True if the mirror image of diag1 equals any rotation of diag2Diagram:Scale all endpoints by factor to allow for additional chordsInvariants for realizable diagrams size=%sget_possible_chords expects exactly one of: chord_count or ep_listReturns True if inner_diag fits into outer_diagReturns the mirror image diagramReturn True if chord diagram can be drawn as a plane diagram
       Diagram cannot be drawn if any chord has even length
       Chord length is even if both endpoints are even or both are odd
    Return true if diagram contains a one-move.
       i.e. if three cords form an adjacency loop - our put another way:
       each chord endpoint is adjacent to another chord's endpoint to form a
       closed loop containing three chords.popfirstminus<lambda>regmgr__str__locatoroutsidereverseiterkeysregion1_region2_regions1regions2node_pairregion_idregionsettemp_span__iteratordifferenceold_regionother_nodesetdefaultbound_spansfinal_chordnode_regionbase_regionsmatch_regionresult_spanssorted_spansstaticmethodcontains_nodecontains_spanexisting_spanvisited_nodesMAX_NODE_LIMIT_is_planarablechords_by_nodeconnector_spanget_lower_nodeget_other_nodeget_upper_nodenew_final_nodesorted_regionsspans_to_checkupdate_regionscomplement_nodeget_base_regionmax_node_closedmin_node_closedname_to_regionsnode_forms_loopreset_region_idget_region_countremove_one_moves_find_closed_loopget_chord_by_nodeis_node_on_regionis_span_on_regionnew_boundary_namecomplement_regionsget_last_region_idget_next_region_idlast_region_closedget_first_region_idget_node_complementget_region_id_afterget_span_complementget_spans_from_nodelowest_intersectionget_regions_for_nodeinit_from_chord_listcomplement_boundariesfinal_node_complementget_regions_for_nodesupdate_dangling_spansget_spans_along_regionlast_assinged_region_idorder_spans_in_closed_loopvalidate_all_regions_closedget_post_intersection_regionReturn region after crossing an intersection, i.e. locator region.
           Finds the region on a span through node that includes new_region
             and returns the opposite region.
        Renumber nodes, removing node numbers that are not used in a chordReturn the span node not matching the specified node

           Args:
               node: Int specifying node not to be returned
           Returns:
               Return the node not matching the specified node
           Raises:
               Exception: original node not found in span
        Return the high valued node of the span

           Args:
               None
           Returns:
               Return the high valued node of the span
           Raises:
               None
        Returns the node that was not specifiedWrong number of base regions #1Represents the chord list definition of a planar diagramReturn True if self entirely contains specified span

           Args:
               span: Span for comparison
           Returns:
               Returns True if self contains or equals specified span
           Raises:
               None
        Each span node is the node of a chord.
           Return the span comprised of the opposite node of each end's chord.
        Returns the canonical boundary name for specified regions

           Args:
               region1, region2: Region IDs to combine into a name
           Returns:
               A name for the boundary along both region1 and region2.
           Raises:
               None
        Starts region numbering over at the beginningReturn the length of the span, i.e. number nodes along the span minus 1

           Args:
               None
           Returns:
               Returns the difference between the high and low nodes.
           Raises:
               None
        Delete any 1-move chords and compress the diagram to ensure
             contiguous nodes
           Removing a 1-move can create a new 1-move.  So iterate until all
             all 1-moves are removed.
        Boundaries: No boundary found containing nodes: %s, %sReturns the number of unit length spans between the chord nodesReturn true if node is within or on border of specified regionConstruct a Chord from an node list, tuple or another ChordUnexpected sorted_regions length: %sReturn the number of defined regions

           Args:
               None
           Returns:
               Returns the number of defined regions
           Raises:
               None
        Return the string format of the Bounaries objectReturn up to two spans emanating from the intersection at node.
           Spans returned are either parallel or perpendicular to span
             containing node, as controlled by the argument: turn.
             Parallel spans: (node, node +/- 1)
             Perpendicular spans: (node_complement, node_comp +/- 1)
           Filter out spans with a node less than 1 or greater than
              last_assigned_node (high node so far in diagram)
           Args:
               node: Node for comparison
               diagram: Diagram for chord (node complement) info
               max_node: Highest valued node crossed at this point
               turn: When "turn" is True, perpendicular spans
                     are returned, else, parallel spans are returned.
               indent: Useful for debug output
           Returns:
               Returns up to two spans coming out of the intersection at span,
                 in the direction specified by the argument 'turn'.
           Raises:
               None
        Return regions list from span containing nodes

           Args:
               node1, node2: Nodes for comparison
           Returns:
               Returns the pair of regions along the span containing both nodes
           Raises:
               Exception: No boundary found containing nodes
        Return region ID after specified region_idAdd new boundary span and note intersection if chord is specified

           Args:
               new_span: Span whose boundary has changed
               region1, region2: Regions on the sides of new_span
               chord (optional): Chord marking a new intersection.  Typically,
                                 passed only for the first span on a new region.
           Returns:
               None
           Raises:
               None
        Return a tuple containing the two parameters in sorted order
       Args:
           a, b: The two values to be returned in the ordered tuple.
       Returns:
           Tuple containing a & b in sorted order,
       Raises:
           None
    Return remaining portions(s) of self after removing span
           Always returns a span list.  Removing the middle of an existing span
             results in two distinct spans
           Endpoint nodes of subtracted span are not removed

           Args:
               span: Segment to remove from self
           Returns:
               Returns a list of 1 or 2 remaining spans
           Raises:
               None
        Wrong number of base regions #2update_regions(%s, old=%s, new=%s): Region '%s' not foundUpdate the region on span, replacing old_region with new_region

           Args:
               span: Span for boundary update
               old_region: Region to be replaced
               new_region: Replacement region
           Returns:
               Returns a region list of resulting regions along specified span
           Raises:
               Exception: Region not found
        No more region identifiersOops, they're not equal - how?Walk along boundary collecting spans
           Start at low node of span
           Search for span bounding specified region by checking the other three
             possible spans from node.
           Collect nodes along region until reaching high end of span
        Return the larger of the chord's two nodesReturn the opposite end of the chord containing specified nodeReturn True if the diagram is planarableReduced diagram:%s: %sother_node(): original node %s not found in span%sNo post intersection region determinedReturn the low valued node of the span

           Args:
               None
           Returns:
               Return the low valued node of the span
           Raises:
               None
        Return last assigned region ID.
           Returns None if no regions have been assigned.
        Update regions along lowest and highest unused spansInvalid diagram.  Missing node: {}Return True if any boundary contains specified span on specified region

           Args:
               match_region: Region for comparison
           Returns:
               Returns True if boundary is found matching both region and span.
               Otherwise, return False.
           Raises:
               None
        Return list of region tuples matching node. Else return None.
           Note: At an intersection, 4 possible spans can each contain node.

           Args:
               node: Node for comparison
           Returns:
               Returns a list of region tuples, the region pairs on each span
               containing specified node.
           Raises:
               Exception: No boundary found containing node

        Returns the number of chords in the diagramToo many chords.  Chord limit: %sReturns the list of boundary spans between the specified regions.
           An empty list is returned if no spans exist on specified regions.

           Args:
               region1, region2: Regions on boundary of interest
           Returns:
               Returns the list of spans on the specified boundary.
           Raises:
               None
        Represents a segment of a planar diagram between nodes
       An ordered pair of nodes - the endpoints of the span
    Needs investigationReturns the region containing the lowest nodes that have not
           been crossed.
        get_regions_for_node: No boundary found containing node: %sTracks boundary info

       A boundary is a region pair plus the list of spans along that boundary.
       The boundary name is a conjunction of the two regions
    Return the chord containing the specified node/Users/melewitz/Documents/LiClipse Workspace/ICDIndicator/Planarable.pyReturn the smaller of the chord's two nodesThe Region class manages region IDs
       It's possible Regions will do more in the future
       First region id is always @ (outside)
       Subsequent ids are A-Z
       TODO: Allow more than 27 regions (@,A-Z)
       Note: Not threadsafe
    Verify that spans on each region boundary form a closed loopReturns the region IDs that comprise the boundary name

           Args:
               name: Boundary name
           Returns:
               Returns the two region IDs for specified boundary name
           Raises:
               None
        No regions found for span %s.
 boundaries: %sBoundaries constructor

           Args:
               None
           Returns:
               Returns a new Boundaries object
           Raises:
               None
        Constructor - Ensure ordering of node pair
           Valid forms:  Span(list), Span(int, int)
           Original node order is saved as: (first, last)
           Nodes of list are kept in sorted order

           Args:
               node1: int, tuple or list
               node2: Must be an in if node1 is an int
                      Ignored when node1 is tuple or list
           Returns:
               A new Span
           Raises:
               None

        Return True if node is on self's span

           Args:
               node: Node for comparison
           Returns:
               Returns True if self.low <= node <= self.high
           Raises:
               None
        Verify that spans can be arranged to form a loop where nodes of
             adjacent spans are either equal or complements.
           Return ordered set of spans or None (if they're not a closed loop)
        Chord diagram operations libraryReturn region_id after last_assigned_region_idRepresents the intersection of two nodesReturn True if the chord containing node closes a loop with no other
             intersections
        (   t   selft   nodet   bounding_spanst   visited_nodest   regiont   intersectionst   diagramt   max_nodet
   final_nodet   boundary_infot   indentt   node_complementt   region_boundariest   new_boundariest   turnt   spans_to_checkt   spant   st   region_count_beforet	   temp_spant   final_node_complementt   new_final_noderbwbargsargvdictdumppathpool<module>isfileCounter_counter_resultsget_lockinitargspropertyincrementrot_resultGetoptErrorinitializer_data_filenamemultiprocessingorig:{} Data load complete.  {} records loadedError: Missing required option '-n'{} Loading data from: {}hn:f:Saving data to:Orig: {} {}
Rot : {} {}{} Starting TEST****-fSave loaded dict data into specified results dictionary
       Can't just assign jsan returned dict, as results is a
         Multiprocessing.Manager.dict
    os.pathusage: {} -n <nchords> [-f <results-file-name>]Verify that is_planarable() returns the same value for all rotations of
       the specified diagram
    Using data file:Error: Number of chords must be great than 0:{} diagram count: {}rot :../check_all_diagrams.pyInitializer for the Multiprocessing.Pool to ensure access to the shared
       resources by all threads/processes
    isplanar.jsonProcess command line arguments and kick things offSuccessfully completed {}-chord testing.  Diagrams: {}Tested all {}-chord diagramsGot n_chords:...done{} test endNo data loaded.  File does not exist:/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python%m/%d/%Y %H:%M:%S__all____builtins____class____cmp____delattr____dict____doc____enter____exit____file____getattr____import____init____main____metaclass____module____name____setattr__appendcompileexc_tracebackexc_typeexc_valueinspectiteritemsopenreprsplitstderrstrftimexrange